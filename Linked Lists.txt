//liste inlantuite (min, max, insert, search, predecesor)
#include <iostream>
#include <climits> // Pentru a folosi constante pentru limitele valorilor întregi
using namespace std;

class Node
{
public :
    int Value;
    Node*  Next;
};

void printList(Node*n)
{
    while(n!=NULL)
    {
        cout << n->Value << endl;
        n = n->Next;
    }
}

void insertAtFront(Node**head, int newValue)
{
    Node* newNode = new Node();
    newNode->Value = newValue;
    
    newNode->Next = *head;
    *head = newNode;
}

void insertAtEnd(Node**head, int newValue)
{
    //Prepare newNode
    Node* newNode = new Node();
    newNode->Value = newValue;
    newNode->Next = NULL;
    
    //Checking if list is empty
    if(*head == NULL)
    {
        *head = newNode;
        return;
    }
    
    //Find last node
    Node*last = *head;
    while(last->Next != NULL)
    {
        last = last->Next;
    }
    
    //Insert newNode at the end
    last->Next = newNode;
}

void insertAfter(Node*previous, int newValue)
{
    //Previous node is not NULL
    if(previous == NULL)
    {
        cout << "Previous can't be NULL";
        return;
    }
    
    //Prepare newNode
    Node*newNode = new Node();
    newNode->Value = newValue;
    
    //Insert newNode after previous node
    newNode->Next = previous->Next;
    previous->Next  = newNode;
}

// Functie pentru a gasi valoarea minima din lista
int minValue(Node* head)
{
    // Initializam valoarea minima cu cel mai mare numar intreg posibil
    int minVal = INT_MAX;

    // Parcurgem lista si actualizam valoarea minima daca gasim o valoare mai mica
    while (head != NULL)
    {
        if (head->Value < minVal)
            minVal = head->Value;
        head = head->Next;
    }

    return minVal;
}

// Functie pentru a gasi valoarea maxima din lista
int maxValue(Node* head)
{
    // Initializam valoarea maxima cu cel mai mic numar intreg posibil
    int maxVal = INT_MIN;

    // Parcurgem lista si actualizam valoarea maxima daca gasim o valoare mai mare
    while (head != NULL)
    {
        if (head->Value > maxVal)
            maxVal = head->Value;
        head = head->Next;
    }

    return maxVal;
}

// Functie pentru a cauta un element in lista
bool search(Node* head, int target)
{
    // Parcurgem lista
    while (head != NULL)
    {
        // Daca gasim valoarea cautata, returnam true
        if (head->Value == target)
            return true;
        head = head->Next;
    }

    // Daca nu gasim valoarea cautata, returnam false
    return false;
}

// Functie pentru a gasi predecesorul unui element in lista
Node* predecesor(Node* head, int target)
{
    // Verificăm dacă lista este goală sau dacă primul nod conține elementul căutat
    if (head == nullptr || head->Value == target)
        return nullptr;

    // Parcurgem lista si cautam predecesorul elementului căutat
    while (head->Next != nullptr)
    {
        // Daca urmatorul nod contine elementul cautat, returnam nodul curent (predecesorul)
        if (head->Next->Value == target)
            return head;

        head = head->Next;
    }

    // Daca nu am gasit elementul cautat in lista, returnam nullptr
    return nullptr;
}

int main()
{
    Node* head = new Node();  //First Node
    Node* second = new Node();
    Node* third = new Node();
    
    head->Value = 1;
    head->Next = second;
    
    second->Value = 2;
    second->Next = third;
    
    third->Value = 4;
    third->Next = NULL;
    
    insertAtFront(&head, -0);
    insertAtFront(&head, -2);
    
    insertAtEnd(&head, 5);
    insertAtEnd(&head, 6);
    
    insertAfter(head, -1);
    insertAfter(second, 3);
    
    printList(head);
    
    // Gasim si afisam valoarea minima si valoarea maxima din lista
    cout << "Valoarea minima din lista: " << minValue(head) << endl;
    cout << "Valoarea maxima din lista: " << maxValue(head) << endl;
    
    // Cautam elementul dorit in lista si afisam rezultatul
    int elementCautat = 3;
    if (search(head, elementCautat))
        cout << "Elementul " << elementCautat << " a fost gasit in lista.\n";
    else
        cout << "Elementul " << elementCautat << " nu a fost gasit in lista.\n";
        
    // Afisam predecesorul elementului cautat (daca exista)
    Node* predecesorElement = predecesor(head, elementCautat);
    if (predecesorElement != nullptr)
        cout << "Predecesorul elementului " << elementCautat << " este: " << predecesorElement->Value << endl;
    else
        cout << "Elementul " << elementCautat << " nu are predecesor.\n";

    return 0;
    
}